<p align="center">
  <img src="/assets/logo.png" alt="logo" title="Летняя стажировка fuse8/byteminds"/>
</p>

# Задание к уроку №5
**К заданию можно приступить только после проверки предыдущего задания**
- Подлить предыдущее задание в ветку `main`
- Перенести созданный солюшен вместе с решением в папку `PetProject`
- Закоммитить это в `main` (**Самостоятельно**. НЕ нужно для этого создавать PR и ждать апрува от нас)
- От этого коммита начать ветку для решения данного домашним заданием
- Выполнять задание нужно в солюшене, которые вы перенесли в папку `PetProject`

Таким образом мы сможем увидеть изменения, которые произошли в вашем проекте после выполнения данного задания

## InternalApi
- В решении `CurrencyApi` добавить новый проект - `InternalApi`
- Настроить проект `InternalApi`, аналогично `PublicApi` из предыдущего задания (настроить логирование, настроить сваггер)
- **Убедиться, что файл `appsettings.Development.json` не попадает в репозиторий.** В этом файле, как и прежде стоит хранить ключ авторизации.
- Перенести в `InternalApi` реализацию взаимодействия с внешним API из предыдущего задания 
- Доработать этот сервис, чтобы он реализовал интерфейс [ICurrencyAPI](Contracts%2FICurrencyAPI.cs)
  ```csharp
  interface ICurrencyAPI
  {
    Task<Currency[]> GetAllCurrentCurrenciesAsync(string baseCurrency, CancellationToken cancellationToken);
  
    Task<CurrenciesOnDate> GetAllCurrenciesOnDateAsync(string baseCurrency, DateOnly date, CancellationToken cancellationToken);
  }
  ```
- Реализовать кэширующий сервис, который реализует интерфейс [ICachedCurrencyAPI](Contracts%2FICachedCurrencyAPI.cs)
  ```csharp
  interface ICachedCurrencyAPI
  {
    Task<CurrencyDTO> GetCurrentCurrencyAsync(CurrencyType currencyType, CancellationToken cancellationToken);

    Task<CurrencyDTO> GetCurrencyOnDateAsync(CurrencyType currencyType, DateOnly date, CancellationToken cancellationToken);
  }

  ```
  - Сервис `ICachedCurrencyAPI` должен обращаться к методам `ICurrencyAPI` только если в его кэше нет данных либо данные устарели.
  - В качестве кэша нужно использовать сохранение данных на диск. 
  - Формат и способ сохранения на диск не важен, например, можно [использовать JSON](https://learn.microsoft.com/ru-ru/dotnet/standard/serialization/system-text-json/how-to?pivots=dotnet-8-0#how-to-write-net-objects-as-json-serialize).
  - Формат имени файла сделать такой, чтобы по нему можно было определить дату.
  - **Файлы кэша НЕ должны попадать в репозиторий**
  - Время устаревания кэша для `ICachedCurrencyAPI.GetCurrentCurrencyAsync` - 2 часа. 
    То есть, вы должны найти файл с максимальной датой.
    Если дата отличается от текущей меньше чем на 2 часа, то вернуть из метода значение из файла.
    Если сохраненного файла нет или дата отличается больше чем на 2 часа, то выполнить метод сервиса `ICurrencyAPI` и сохранить данные на диск. 
    В качестве даты для имени файла нужно использовать текущую дату со временем
  - Для проверки устаревания кэша для `ICachedCurrencyAPI.GetCurrencyOnDateAsync` должен находить файл с той же датой, для которой делают запрос. 
    Выбирать файлы следует без учета времени. 
    То есть если есть файл полученный 27 июля в 12:43 и файл полученный 27 июля в 18:19 то оба файла попадают под выборку.
    Если файл с данной датой один, то вернуть из метода данные из этого файла.
    Если файлов несколько, то вернуть данные из файла, у которого самое большое время.
    Если файлов с данной датой нет, то выполнить метод сервиса `ICurrencyAPI` и сохранить данные на диск. 
    В качестве даты для имени файла нужно использовать дату `CurrencyOnDateDTO.LastUpdatedAt`
  - Методы `ICachedCurrencyAPI` должны использовать единый кэш. 
  То есть, если 27 июля был вызван метод `ICachedCurrencyAPI.GetCurrentCurrencyAsync` и он добавил файл `27 июля в 18:19`, 
  то при вызове метода `ICachedCurrencyAPI.GetCurrencyOnDateAsync("27 июля")` вернутся данные из этого файла без дополнительного запроса к API.

- Добавить `.proto` файл с описанием grpc сервиса для выполнения следующих действий
  - Получить текущий курс определенной валюты 
  - Получить курс определенной валюты на конкретную дату
  - Получить настройки 
    - Базовая валюта
    - Есть ли еще доступные запросы (`bool value = requestLimit > requestCount`)
- Сгенерировать `gRPC-сервис` по созданному `.proto` (только сервер, без клиента) и добавить реализацию методов
  - Методы `gRPC-сервиса` должны вызывать методы сервиса `ICachedCurrencyAPI` 
  - `gRPC-сервис` должен преобразовывать модели, которые возвращает `ICachedCurrencyAPI` в свои модели (которые сгенерированы по `.proto`)
- Сделать `REST-API` в проекте `InternalApi`, который будет повторять методы `gRCP-сервиса` и дополнительно реализовывать хелсчек
- Все контроллеры, экшены, модели должны иметь описание
- При запуске приложение открывает два порта. Один использовать для gRPC, второй для REST-апи.
- Настроить, чтобы доступ к gRPC сервису был только с одного порта. Порт брать из конфигурации приложения.
- Настроить, чтобы по порту gRPC нельзя было получить доступ к REST-апи

## PublicApi
- Добавить `.proto`, созданный в `InternalApi`
- Сгенерировать `gRPC-клиент` по созданному `.proto` (только клиент, без сервиса)
- Зарегистрировать клиента. URL до `InternalApi` должен браться из конфигурации приложения
- Использовать созданного клиента, для получения курсов валют (там где раньше был вызов httpClient-а теперь будет вызов gRPC клиента)
- Настроить логирование запросов `gRPC-клиента`. Используйте для этого библиотеку Audit.Net
- Доработать метод `GET /settings`, созданный в предыдущем задании. Должен возвращаться джейсон вида
  ```
  {
    "defaultCurrency": "RUB", // текущий курс валют по умолчанию из конфигурации
    "baseCurrency": "USD", // базовая валюта, относительно которой считается курс (возвращается из gRPC) 
    "newRequestsAvailable": bool, // есть ли еще доступные запросы (возвращается из gRPC)
    "currencyRoundCount": 2 // Количество знаков после запятой, до которого следует округлять значение курса валют
  }
  ```